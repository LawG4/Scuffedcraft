# Core Python imports
import json
import math
import os

# Python packages you'll need to add
from PIL import Image #Requires pip install Pillow

# Local python files
from Indices import generateIndicesFiles

# This python script turns the json file of standard blocks, and turns them into asset files that we can use in the engine.
# 
# Files Generated
# 	* Assets/StandardBlocks.h : Declare the vertices of a cube, tex coordinates of each block. Include the texture atlas
#	* Assets/StandardBlocks/StandardBlocks.c : Define the vertices of a cube, tex coordinates of each block
#	* Assets/StandardBlocks/TextureAtlas.h : Generated via devkit pro for a wii optimised file, made from the texture atlas
#	* Assets/StandardBlocks/TextureAtlas.c : Generated via devkit pro for a wii optimised file, made from the texture atlas
#	* ./TextureAtlas.png : The actually png image of the texture atlas that will be transformed.
#

# Reset the files listed above 
pathToAssetsFolder = "../../source/Assets/"
StandardBlocksHeaderFilePath = pathToAssetsFolder + "StandardBlocks.h"
StandardBlocksSourceFilePath = pathToAssetsFolder + "StandardBlocks/StandardBlocks.c"

# Check if the asset folders actually exist and if they don't create them.
if not os.path.exists(pathToAssetsFolder):
		os.makedirs(pathToAssetsFolder)
if not os.path.exists(pathToAssetsFolder + "StandardBlocks/" ):
		os.makedirs(pathToAssetsFolder + "StandardBlocks/")

# Add start of a header guard to the standard blocks header
fileHeader = """/* Auto generated by the Scuffedcraft build system */ \n\n"""
HeaderFile = open(StandardBlocksHeaderFilePath, "w") 
HeaderFile.write(fileHeader + "#ifndef SC_STANDARD_BLOCK_AUTO_GEN_H \n#define SC_STANDARD_BLOCK_AUTO_GEN_H \n")

# Add include of the header file to the source file
SourceFile = open(StandardBlocksSourceFilePath, "w") 
SourceFile.write(fileHeader + """#include \"../StandardBlocks.c\" \n""")



#
# Set up the resources that we need to create for the automatically generated resources
# Such as :
# 	* The vertices declarations
#	* a struct for the texture array
#	* The tex coordinate array decleration
#
HeaderFile.write("""
/*Vertices*/
extern float sc_standard_block_face_north[12];
extern float sc_standard_block_face_east[12];
extern float sc_standard_block_face_south[12];
extern float sc_standard_block_face_west[12];
extern float sc_standard_block_face_top[12];
extern float sc_standard_block_face_bottom[12];

/*Struct for the indices*/
typedef struct sc_standard_block_indices
{
	float north[8];
	float east[8];
	float south[8];
	float west[8];
	float top[8];
	float bottom[8];
} sc_standard_block_indices;
""")

# Read in the json config file and dump it into a block data dictionary 
# Use the length of the dictionary to reserve enough space for them
file = open('00-Textures.json',)
blockData = json.load(file)
file.close()

# Reserve space for the indices by counting the number of entries 
blockCount = len(blockData['standard-blocks'])
HeaderFile.write("extern const sc_standard_block_indices standardBlocksByID[" + str(blockCount) + "];\n")

# Store in code how many unique block types there are so we don't loop too many times
HeaderFile.write("extern const int standardBlocksByIDCount;\n")

# Final part for the header file close the header guard 
HeaderFile.write("\n#endif")
print("Header file generation finished")



#
# Start the generation of the source file
# For this we need to actually define the forward declared variables 
# Starting with the vertices for the different faces.
#

SourceFile.write("""
/*Define the forward declared block vertices
 * -------------------------------------     x1     x2     x3     x4     y1     y2     y3     y4     z1     z2     z3    z4   ;  
 */
float sc_standard_block_face_north[12]  = {-0.5f,  0.5f,  0.5f, -0.5f,  0.5f,  0.5f, -0.5f, -0.5f,  0.5f,  0.5f,  0.5f,  0.5f};
float sc_standard_block_face_east[12]   = { 0.5f, -0.5f, -0.5f,  0.5f,  0.5f,  0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f};
float sc_standard_block_face_south[12]  = {-0.5f,  0.5f,  0.5f, -0.5f,  0.5f,  0.5f,  0.5f,  0.5f,  0.5f,  0.5f, -0.5f, -0.5f};
float sc_standard_block_face_west[12]   = {-0.5f,  0.5f,  0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f,  0.5f,  0.5f, -0.5f, -0.5f};
float sc_standard_block_face_top[12]    = {-0.5f, -0.5f, -0.5f, -0.5f,  0.5f,  0.5f, -0.5f, -0.5f, -0.5f,  0.5f,  0.5f, -0.5f};
float sc_standard_block_face_bottom[12] = { 0.5f,  0.5f,  0.5f,  0.5f,  0.5f,  0.5f, -0.5f, -0.5f,  0.5f, -0.5f, -0.5f,  0.5f};
""")

# Define the forward declared size of the standard block array
SourceFile.write("\n\n/*Start defining the auto generated texture coordinates for each face on each block*/\nconst int standardBlocksByIDCount = " + str(blockCount) +";\n")

#
# Start generating the texture atlas as a bitmap
# Get all of the unique texture names referenced throughout the json file 
# Place them in a coordinate in a bitmap, then turn those into texture coordinates 
# Use the texture name as a dictionary to get the tex coordinates so we can write them later 
#

# Loop through the json list and get all of the texture names mentioned
textureNames = []
for x in blockData['standard-blocks']:
	textureNames.append(x['block-texture-n'])
	textureNames.append(x['block-texture-e'])
	textureNames.append(x['block-texture-s'])
	textureNames.append(x['block-texture-w'])
	textureNames.append(x['block-texture-t'])
	textureNames.append(x['block-texture-b'])

# Now get only the unique texture names
uniqueTextureNames = list(set(textureNames))
texture_indices_dict = dict.fromkeys(uniqueTextureNames, [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])
texture_indices_dict["99_Unknown_Texture.png"] = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]]
# Find the first square number larger than the number of unique textures
# This might need rounding up to the next power of two as well
atlasWidth = math.ceil(math.sqrt(len(uniqueTextureNames)))

# Set the size of the face in pixels 
faceSizeInPixels = 16

# Padding for the textures
texturePad = 1

# Calculate the size of the texture atlas 
atlasSize = (atlasWidth * (faceSizeInPixels + 2 * texturePad), atlasWidth * (faceSizeInPixels + 2 * texturePad))
atlasImage = Image.new( mode="RGB", size=atlasSize )

print("Placing ", len(uniqueTextureNames), " textures into a texture atlas of size : (", atlasSize[0], ", ", atlasSize[1], ")")

# Go by the left top corner of the texture
x = texturePad
y = texturePad

# Go through each unique texutre 
for textureName in uniqueTextureNames:
	# Test if the texture from the json file exists
	if not os.path.isfile(textureName):
		textureFileName = "99_Unknown_Texture.png"
	else:
		textureFileName = textureName
	
	# Copy the image to the texture atlas
	newTexture = Image.open(textureFileName)
	atlasImage.paste(newTexture, (x,y), newTexture)
	newTexture.close()

	# Generate the texture coordinates, inorder to ensure that we don't get bleading
	# we need to place the texels in the middle of the pixel

	# Coordinates are written clockwise from top left
	
	indices = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]]
	indices[0] = [(x + 0.5) / atlasSize[0], (y + 0.5) / atlasSize[1]]
	indices[1] = [(x + faceSizeInPixels - 0.5) / atlasSize[0], (y + 0.5) / atlasSize[1]]
	indices[2] = [(x + faceSizeInPixels - 0.5) / atlasSize[0], (y + faceSizeInPixels - 0.5) / atlasSize[1]]
	indices[3] = [(x + 0.5) / atlasSize[0], (y + faceSizeInPixels - 0.5) / atlasSize[1]]
	texture_indices_dict[textureName] = indices

	# Move the texture coordinate for the next image
	x = x + faceSizeInPixels + texturePad
	if x + faceSizeInPixels + texturePad > atlasSize[0]:
		x = texturePad
		y = y + faceSizeInPixels + texturePad

print("Saving output image")
atlasImage.save('out.bmp')

#
# Finish writing to the source file by taking each of the blocks and writing the indices out
#
def writeIndices(FaceName, textureName):
	indices = texture_indices_dict[textureName]
	SourceFile.write("\n\t\t\t/* " + '%-6s' % FaceName + " : " + textureName + " */\n")
	SourceFile.write("\t\t\t{" +  str(indices[0][0]) + ", " +  str(indices[0][1]) + ", " +  str(indices[1][0]) + ", " +  str(indices[1][1]) + ", " +
		  str(indices[2][0]) + ", " +  str(indices[2][1]) + ", " +  str(indices[3][0]) + ", " +  str(indices[3][1]) + " },")

SourceFile.write("const sc_standard_block_indices standardBlocksByID[" + str(blockCount) + "] = \n\t{")

# For each block go through each face and write out the indices
for block in blockData['standard-blocks']:
	SourceFile.write("\n\t/* " + block['block-name'] + " */\n\tsc_standard_block_indices\n\t\t{")

	writeIndices("North", block['block-texture-n'])
	writeIndices("East", block['block-texture-e'])
	writeIndices("South", block['block-texture-s'])
	writeIndices("West", block['block-texture-w'])
	writeIndices("Top", block['block-texture-t'])
	writeIndices("Bottom", block['block-texture-b'])

	#Get rid of the last comma and then close the array
	SourceFile.seek(SourceFile.tell() -1, os.SEEK_SET)
	SourceFile.write("\n\t\t},")

#Get rid of the last comma and then close the array
SourceFile.seek(SourceFile.tell() -1, os.SEEK_SET)
SourceFile.write("\n\t};")